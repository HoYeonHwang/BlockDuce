이 글은 아래의 버전을 기준으로 작성되었습니다. 체인코드(스마트 컨트랙트)와 SDK는 자바를 활용하여 개발되었습니다.

# 🖥 환경 구성:

하이퍼레저 패브릭 네트워크는

- **피어 5개 (인돌서 2개)**
- **오더러 5개**
- **CA 3개 (Org가 3개이기 때문)**
- **tools (cli — 네트워크 조작용) 1개**

로 구성됩니다. 모든 물리적 서버는 아래와 같이 모두 동일한 환경으로 구성되어있습니다.

- 물리적인 서버 컴퓨터 5대 연결
- 우분투: 18.04
- 자바: openjdk11

우분투는 16.04를 사용하셔도 무방합니다. JDK8도 호환됩니다.

- 하이퍼레저 패브릭: v1.4.6

패브릭의 경우 v1.4.7 버전까지는 문제없이 동작하는 것을 확인하였습니다.

- 도커 및 도커 컴포즈: 19.03.6 & 1.17.1
- YAML: 3.8

도커는 스웜 활용을 위해 19.03.6 버전 이상을 활용해주세요. YAML 버전도 3.3 버전 이상 사용해주세요.

# 👀 도커 이미지:

도커 허브에 있는 하이퍼레저 패브릭 피어, 오더러, CA, tools를 활용합니다.

이미지의 버전은 1.4.6 버전으로 하시길 권장드립니다. 패브릭 2.x 버전은 알려드리는 방법과 호환되지 않을 수 있습니다.

```
# fabric-samples에서 사용하는 이미지와 동일합니다.
docker pull hyperledger/fabric-peer:1.4.6
docker pull hyperledger/fabric-orderer:1.4.6
docker pull hyperledger/fabric-ca:1.4.6
docker pull hyperledger/fabric-tools:1.4.6
```

패브릭의 네트워크 합의 알고리즘은 raft로 구성했습니다. kafka로 구성할 경우 설정을 달리하고 도커로 kafka와 zookeeper를 도커로 띄워야합니다. 이 글에서는 kafka를 활용한 합의 알고리즘에 대해 언급하지 않습니다.

```
$ docker images
REPOSITORY                       TAG        IMAGE ID            CREATED             SIZE
hyperledger/fabric-ca            1.4.6      3b96a893c1e4        12 months ago       150MB
hyperledger/fabric-tools         1.4.6      0f9743ac0662        12 months ago       1.49GB
hyperledger/fabric-orderer       1.4.6      84eaba5388e7        12 months ago       120MB
hyperledger/fabric-peer          1.4.6      5a52faa5d8c2        12 months ago       128MB
```

# 🔗 도커 스웜 네트워크 구축

# 도커 스웜 생성

아무 노드를 선택해도 상관 없으며, 생성한 노드는 매니저로 지정됩니다.

예제에서는 server 1, 2, 3, 4, 5 이 있다고 가정하고 server 1에서 init을 진행했다고 가정합니다.

```
> docker swarm init --advertise-addr [server 1 ip:port] # --advertise-addr는 외부 서버가 존재한다면 반드시 설정해야함. 생략시 기본값으로 내부 ip로 설정됨
Swarm initialized: current node (mdd0e2xrufx3dt5ndoweefhsq) is now a manager.To add a worker to this swarm, run the following command:    docker swarm join --token SWMTKN-1-4js4u9rxcbnu96lb52av6sngjh7bmt2up8cwydrae0jy6dpiow-2dupgfkwjgmnet2ql6ufclpqo [server 1 ip:port] 
		# 해당 명령어를 복사하여 네트워크에 포함시키고자하는 서버에 입력To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.
```

# 워커 노드 설정

server 1이 스웜을 생성하고 server 2, 3, 4, 5 에서 앞에서 생성한 코드를 실행합니다.

워커 노드는 매니저 노드로 변경할 수 있습니다. 매니저 노드는 네트워크의 유지 및 관리를 위해 3, 5, 7 등의 숫자로 유지되어야 합니다. 매니저 노드만이 도커 스웜을 관리할 수 있습니다.

```
# 도커 스웜 생성(init)에 의해 생성된 값을 복사하여 입력하며 추가로 --advertise-addr [current ip:port]를 입력하여 현재 노드를 인식할 수 있도록 함.
# --advertise-addr [ip:port] 를 설정하지 않을 경우 마찬가지로 내부 ip로 설정됨
docker swarm join --token SWMTKN-1-4js4u9rxcbnu96lb52av6sngjh7bmt2up8cwydrae0jy6dpiow-2dupgfkwjgmnet2ql6ufclpqo [server 1 ip:port] --advertise-addr [current ip:port]# 워커 노드 매니저 노드로 변경, server name은 host name을 의미함
docker node promote [server name]
```

# 오버레이 네트워크 생성

체인코드를 활용하기 위해 반드시 다음과 같이 설정하여 네트워크를 생성해야합니다.

```
docker network create -d overlay --attachable [network name]
```

# 도커 스웜 확인

```
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
b122f2d6ddf1        bridge              bridge              local
bf5eba8c9b32        docker_gwbridge     bridge              local
3c151cfaf38b        host                host                local
hzakfrmqtlm2        ingress             overlay             swarm
9eb950e92d40        none                null                local
rj4oqjgr0tff        [network name]      overlay             swarm$ docker node ls
ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION
y0af74gpp00m779k26agftnq7     server1             Ready               Active              Reachable           19.03.6
xkoudxzncszwssqvmxhig2kak *   server2             Ready               Active              Leader              19.03.6
gsf163ra5s7h0iqg66yhlpvmc     server3             Ready               Active                                  19.03.6
o40ddoijau0a068h8599kffjc     server4             Ready               Active                                  19.03.6
p7yvh1eljg6df9l8m4ix88mbh     server5             Ready               Active              Reachable           19.03.6
```

위와 같이 수행하셨다면 **하이퍼레저 패브릭과 도커 스웜을 활용할 수 있는 준비**가 완료되었습니다.

# 🗂 하이퍼레저 패브릭 설정 파일

하이퍼레저 패브릭의 cryptogen, configtxgen과 crypto-config.yaml, configtx.yaml에 대한 개념을 숙지했다고 가정한 상태에서 변경이 필요한 부분만을 언급합니다.

해당하는 부분에 주석으로 내용을 입력해두었습니다.

아래의 내용은 하나의 샘플이며, 배포하고자 하는 환경 구성에 맞게 YAML 파일에 피어와 오더러를 추가해주어야 합니다.

커스터마이징이 필요한 부분은 **굵은 글씨**로 표시합니다. 주석으로 표시한 곳 이외에는 작성된 값 사용을 사용합니다.

# crypto-config.yaml

블록체인 네트워크의 구성에 맞는 cert와 msp를 만들기 위해 사용되는 파일입니다.

CA 기능을 활용할 수도 있지만 이 글에서는 cryptogen으로 수작업으로 만드는 방법입니다.

⭐️ 외부망을 활용할 예정이라면 네트워크 관련 설정을 추가해주어야합니다.

```
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0
## ---------------------------------------------------------------------------
# "OrdererOrgs" - Definition of organizations managing orderer nodes
# ---------------------------------------------------------------------------
OrdererOrgs:
  # ---------------------------------------------------------------------------
  # Orderer
  # ---------------------------------------------------------------------------
  - Name: Orderer
    Domain: ssel.jbnu
    EnableNodeOUs: true
    # ---------------------------------------------------------------------------
    # "Specs" - See PeerOrgs below for complete description
    # ---------------------------------------------------------------------------
    Specs:
      **- Hostname: orderer1
        SANS: # 외부망을 이용할 경우 ip/url을 반드시 입력해야 정상적으로 동작함
          - "xxx.xxx.xxx.xx1"
          - "domain1.com"**      - Hostname: orderer2
        SANS:
          **- "xxx.xxx.xxx.xx2"
          - "domain2.com"**
			...# ---------------------------------------------------------------------------
# "PeerOrgs" - Definition of organizations managing peer nodes
# ---------------------------------------------------------------------------
PeerOrgs:
  # ---------------------------------------------------------------------------
  # Org1
  # ---------------------------------------------------------------------------
  - Name: Org1
    Domain: org1.ssel.jbnu
    EnableNodeOUs: true
    # ---------------------------------------------------------------------------
    # "Specs"
    # ---------------------------------------------------------------------------
    # Uncomment this section to enable the explicit definition of hosts in your
    # configuration.  Most users will want to use Template, below
    #
    # Specs is an array of Spec entries.  Each Spec entry consists of two fields:
    #   - Hostname:   (Required) The desired hostname, sans the domain.
    #   - CommonName: (Optional) Specifies the template or explicit override for
    #                 the CN.  By default, this is the template:
    #
    #                              "{{.Hostname}}.{{.Domain}}"
    #
    #                 which obtains its values from the Spec.Hostname and
    #                 Org.Domain, respectively.
    # ---------------------------------------------------------------------------
    # Specs:
    #   - Hostname: foo # implicitly "foo.org1.ssel.jbnu"
    #     CommonName: foo27.org5.ssel.jbnu # overrides Hostname-based FQDN set above
    #   - Hostname: bar
    #   - Hostname: baz
    # ---------------------------------------------------------------------------
    # "Template"
    # ---------------------------------------------------------------------------
    # Allows for the definition of 1 or more hosts that are created sequentially
    # from a template. By default, this looks like "peer%d" from 0 to Count-1.
    # You may override the number of nodes (Count), the starting index (Start)
    # or the template used to construct the name (Hostname).
    #
    # Note: Template and Specs are not mutually exclusive.  You may define both
    # sections and the aggregate nodes will be created for you.  Take care with
    # name collisions
    # ---------------------------------------------------------------------------
    Template:
      Count: 2
      **SANS: # 피어도 오더러와 마찬가지로 ip/url에 대한 정보 필요
          - "xxx.xxx.xxx.xx3"
          - "domain3.com"**
      # Start: 5
      # Hostname: {{.Prefix}}{{.Index}} # default
    # ---------------------------------------------------------------------------
    # "Users"
    # ---------------------------------------------------------------------------
    # Count: The number of user accounts _in addition_ to Admin
    # ---------------------------------------------------------------------------
    Users:
      Count: 1
```

# configtx.yaml

블록체인 네트워크의 gennesis.block, channel.tx, anchorPeer.tx 등에 네트워크 설정과 구성을 입력합니다.

⭐️ 모든 피어와 오더러는 아래와 같이 사용하고자 하는 네트워크 설정과 구성으로만 동작해야합니다.

```
Organizations:
    ...    - &Org1
        # DefaultOrg defines the organization which is used in the sampleconfig
        # of the fabric.git development environment
        **Name: Org1MSP**        # ID to load the MSP definition as
        **ID: Org1MSP**        MSPDir: crypto-config/peerOrganizations/org1.ssel.jbnu/msp        # Policies defines the set of policies at this level of the config tree
        # For organization policies, their canonical path is usually
        #   /Channel/<Application|Orderer>/<OrgName>/<PolicyName>
				#####################################
				# 조직 권한 부여 커스터마이즈 가능
        Policies:
            Readers:
                Type: Signature
                Rule: "OR('Org1MSP.admin', 'Org1MSP.peer', 'Org1MSP.client')"
            Writers:
                Type: Signature
                Rule: "OR('Org1MSP.admin', 'Org1MSP.client')"
            Admins:
                Type: Signature
                Rule: "OR('Org1MSP.admin')"        # leave this flag set to true.
        AnchorPeers:
            # AnchorPeers defines the location of peers which can be used
            # for cross org gossip communication.  Note, this value is only
            # encoded in the genesis block in the Application section context
            **- Host: [ip/url]
              Port: [port]**
	...
# 오더러 설정
Orderer: &OrdererDefaults    # Orderer Type: The orderer implementation to start
    # Available types are "solo","kafka"  and "etcdraft"
    **OrdererType: etcdraft # etcdraft로 합의 알고리즘 설정**    # Batch Timeout: The amount of time to wait before creating a batch
    ****BatchTimeout: 2s 
****
    # Batch Size: Controls the number of messages batched into a block
    BatchSize:        # Max Message Count: The maximum number of messages to permit in a batch
        MaxMessageCount: 100        # Absolute Max Bytes: The absolute maximum number of bytes allowed for
        # the serialized messages in a batch.
        AbsoluteMaxBytes: 500 MB        # Preferred Max Bytes: The preferred maximum number of bytes allowed for
        # the serialized messages in a batch. A message larger than the preferred
        # max bytes will result in a batch larger than preferred max bytes.
        PreferredMaxBytes: 512 KB    # EtcdRaft defines configuration which must be set when the "etcdraft"
    # orderertype is chosen.
		**# Host, port, ClientTLSCert, ServerTLSCert는 오더러별로 지정함
		# 해당 경로는 cryptogen을 통해 생성된 값 입력**
    **EtcdRaft:
        Consenters:
          - Host: [server 1 ip/url]
            Port: [port]
            ClientTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer1.ssel.jbnu/tls/server.crt
            ServerTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer1.ssel.jbnu/tls/server.crt
          - Host: [server 2 ip/url]
            Port: [port]
            ClientTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer2.ssel.jbnu/tls/server.crt
            ServerTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer2.ssel.jbnu/tls/server.crt
          - Host: [server 3 ip/url]
            Port: [port]
            ClientTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer3.ssel.jbnu/tls/server.crt
            ServerTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer3.ssel.jbnu/tls/server.crt
          - Host: [server 4 ip/url]
            Port: [port]
            ClientTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer4.ssel.jbnu/tls/server.crt
            ServerTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer4.ssel.jbnu/tls/server.crt
          - Host: [server 5 ip/url]
            Port: [port]
            ClientTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer5.ssel.jbnu/tls/server.crt
            ServerTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer5.ssel.jbnu/tls/server.crt
    Addresses:
        - [server 1 ip/url]:[port]
        - [server 2 ip/url]:[port]
        - [server 3 ip/url]:[port]
        - [server 4 ip/url]:[port]
        - [server 5 ip/url]:[port]
	...# genesis block과 channel 설정을 위한 프로파일**
Profiles:
    **ThreeOrgsChannel: # 프로파일 이름 변경 가능
        Consortium: SampleConsortium # 컨소시엄 변경 가능**
        <<: *ChannelDefaults
        Application:
            <<: *ApplicationDefaults
            **Organizations: # 설정하고자 하는 구성과 맞게 아래 목록 입력
                - *Org1    # 윗부분에 작성한 조직을 참조함
                - *Org2
                - *Org3**
            Capabilities:
                <<: *ApplicationCapabilities    SampleMultiNodeEtcdRaft:
        <<: *ChannelDefaults
        Capabilities:
            <<: *ChannelCapabilities
        Orderer:
            <<: *OrdererDefaults
            **OrdererType: etcdraft
            EtcdRaft:
				        Consenters:
				          - Host: [server 1 ip/url]
				            Port: [port]
				            ClientTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer1.ssel.jbnu/tls/server.crt
				            ServerTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer1.ssel.jbnu/tls/server.crt
				          - Host: [server 2 ip/url]
				            Port: [port]
				            ClientTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer2.ssel.jbnu/tls/server.crt
				            ServerTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer2.ssel.jbnu/tls/server.crt
				          - Host: [server 3 ip/url]
				            Port: [port]
				            ClientTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer3.ssel.jbnu/tls/server.crt
				            ServerTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer3.ssel.jbnu/tls/server.crt
				          - Host: [server 4 ip/url]
				            Port: [port]
				            ClientTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer4.ssel.jbnu/tls/server.crt
				            ServerTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer4.ssel.jbnu/tls/server.crt
				          - Host: [server 5 ip/url]
				            Port: [port]
				            ClientTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer5.ssel.jbnu/tls/server.crt
				            ServerTLSCert: crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer5.ssel.jbnu/tls/server.crt
				    Addresses:
				        - [server 1 ip/url]:[port]
				        - [server 2 ip/url]:[port]
				        - [server 3 ip/url]:[port]
				        - [server 4 ip/url]:[port]
				        - [server 5 ip/url]:[port]**            Organizations:
            - *OrdererOrg
            Capabilities:
                <<: *OrdererCapabilities
        Application:
            <<: *ApplicationDefaults
            Organizations:
            - <<: *OrdererOrg
        **Consortiums:
            SampleConsortium:
                Organizations:
                - *Org1
                - *Org2
                - *Org3**
```

# 결과물

fabric-samples 예제에서 생성되는 결과물과 동일합니다. 네트워크 설정과 구성에 맞게 생성되도록만 바뀌었습니다.

crtyptogen.yaml에 의한 생성물

configtx.yaml에 의해 생성되는 파일

**생성된 파일들은 cert와 msp의 경우 각 피어와 오더러에 맞게 위치해주어야 합니다.** 예를 들어 서버 1에서 org 1에 peer 0을 동작한다면 해당하는 cert와 msp 파일이 서버 1 저장소에 존재해야합니다. 그리고 해당 경로를 도커 컨테이너에 마운트(volume 활용)해야 합니다.

**channel-artifacts**는 cli(tools)를 띄워둔 서버에서 동작해야합니다. cli를 동작시키는 서버만 소유하고 있으면 됩니다.

# 📃 도커 컴포즈 파일 작성

도커 스웜에서 하이퍼레저 피어, 오더러, ca, tools 등을 동작시키기 위해 도커 컴포즈 파일을 작성합니다.

도커 컴포즈 파일은 YAML 파일을 통해 작성되면 3 버전 이상을 반드시 사용해야합니다.

아래의 내용은 하나의 샘플이며, 배포하고자 하는 환경 구성에 맞게 YAML 파일에 피어와 오더러를 추가해주어야 합니다.

커스터마이징이 필요한 부분은 **굵은 글씨**로 표시합니다. 주석으로 표시한 곳 이외에는 작성된 값 사용을 사용합니다.

# 도커 컴포즈 파일 작성 예시

- docker-compose.yaml

```
# Copyright IBM Corp. All Rights Reserved.
#
# SPDX-License-Identifier: Apache-2.0version: '3.8'#########################################################
# 띄우고자 하는 서비스와 네트워크를 띄우고자 하는 환경에 맞게 입력
# 도커 컴포즈 3버전 레퍼런스 참고
# <https://docs.docker.com/compose/compose-file/compose-file-v3/>
########################################################
**volumes:
  orderer2.ssel.jbnu:
  peer1.org1.ssel.jbnu:networks:
  [network name]:
    external: 
      name: ssel**services:
  ca1:
    image: hyperledger/fabric-ca:1.4.6
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca-org1
      - FABRIC_CA_SERVER_TLS_ENABLED=true
			###### cryptogen에 의해 생성된 cert, msp에 해당하는 값을 일치하도록 입력
      **- FABRIC_CA_SERVER_TLS_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.ssel.jbnu-cert.pem
      - FABRIC_CA_SERVER_TLS_KEYFILE=/etc/hyperledger/fabric-ca-server-config/e5a2abd63122bf7d30e7f316391e9d202cb53899efac6703b8ae79859b7dedff_sk**
      - FABRIC_CA_SERVER_PORT=7054
    ports:
      - **[host port]:**7054
    command: sh -c 'fabric-ca-server start --ca.certfile /etc/hyperledger/fabric-ca-server-config/ca.org1.ssel.jbnu-cert.pem --ca.keyfile /etc/hyperledger/fabric-ca-server-config/e5a2abd63122bf7d30e7f316391e9d202cb53899efac6703b8ae79859b7dedff_sk -b admin:adminpw -d'
    volumes:
      **- [file path]/crypto-config/peerOrganizations/org1.ssel.jbnu/ca/:/etc/hyperledger/fabric-ca-server-config**
    networks:
      **[network name]**:
        aliases:
          - ca.org1.ssel.jbnu  **orderer2:**
    **image: hyperledger/fabric-orderer:1.4.6 # 원하는 버전 입력**
    environment:
      - FABRIC_LOGGING_SPEC=INFO
      - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
      - ORDERER_GENERAL_GENESISMETHOD=file
      - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/orderer.genesis.block
      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP
      - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp
      # enabled TLS
      - ORDERER_GENERAL_TLS_ENABLED=true
      - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key
      - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt
      - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]
      - ORDERER_GENERAL_CLUSTER_CLIENTCERTIFICATE=/var/hyperledger/orderer/tls/server.crt
      - ORDERER_GENERAL_CLUSTER_CLIENTPRIVATEKEY=/var/hyperledger/orderer/tls/server.key
      - ORDERER_GENERAL_CLUSTER_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt]
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric
    command: orderer
		
		####################################################
		# volume 마운트 필요
		# cert, msp, block, channel 등의 파일을 연결시켜주기 위함
		####################################################
    **volumes:
      - [file path]/channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block
      - [file path]/crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer2.ssel.jbnu/msp:/var/hyperledger/orderer/msp
      - [file path]/crypto-config/ordererOrganizations/ssel.jbnu/orderers/orderer2.ssel.jbnu/tls/:/var/hyperledger/orderer/tls
      - [file path]/production/orderer:/var/hyperledger/production/orderer # 입력되는 cert, msp와 생성되는 블록과 트랜잭션의 저장소**
    deploy:
        mode: replicated
        replicas: 1
        restart_policy:
          condition: on-failure
		########################################################
		# 노출하고자 하는 포트 설정
		# 피어는 각자 구분되도록 일일이 작성해줘야함(replicated로 동일한 여러 피어 생성 X)
		# - 각자에 맞는 cert, msp 할당을 위해
		########################################################
    **ports:
      - [host port]:7050**
    **networks:
      [network name]:
        aliases:
          - orderer2.ssel.jbnu**  **peer1org1:**
		##################################################
		# 원하는 버전 이미지로 변경
		##################################################
    **image: hyperledger/fabric-peer:1.4.6**
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      # the following setting starts chaincode containers on the same
      # bridge network as the peers
      # <https://docs.docker.com/compose/networking/>
      **- CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=[network ID] # 도커 스웜 오버레이 네트워크 입력**
      - FABRIC_LOGGING_SPEC=INFO
      #- FABRIC_LOGGING_SPEC=DEBUG
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_GOSSIP_USELEADERELECTION=true
      - CORE_PEER_GOSSIP_ORGLEADER=false
      - CORE_PEER_PROFILE_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt
      - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt
			##################################################
			# 피어의 네트워크 설정 필요
			# 아래의 []로 표시된 내용을 네트워크 환경에 맞게 입력해주어야 함
			##################################################
      **- CORE_PEER_ID=peer1.org1.ssel.jbnu
      - CORE_PEER_ADDRESS=[현재 피어 ip/url]:7051 # 현재 작성된 피어가 통신하기 위한 주소, 포트 변경 불필요**
      - CORE_PEER_LISTENADDRESS=0.0.0.0:7051  
      **- CORE_PEER_CHAINCODEADDRESS=[현재 피어 ip/url]:7052 # 체인코드와 연결하기 위한 주소, 포트 변경 불필요** 
      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052
      **- CORE_PEER_GOSSIP_BOOTSTRAP=[동일한 조직의 다른 피어 ip/url]:[피어 port] # 패브릭 네트워크 연결을 위한 다른 피어 주소
      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=[현재 피어 ip/url]:[피어 port] # 패브릭 네트워크와 통신하기 위한 주소
      - CORE_PEER_LOCALMSPID=[조직 ID] # 현재 피어의 조직 id**
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
    command: peer node start
    **volumes:**
        - /var/run/:/host/var/run/
        **- [file path]/crypto-config/peerOrganizations/org1.ssel.jbnu/peers/peer1.org1.ssel.jbnu/msp:/etc/hyperledger/fabric/msp
        - [file path]/crypto-config/peerOrganizations/org1.ssel.jbnu/peers/peer1.org1.ssel.jbnu/tls:/etc/hyperledger/fabric/tls
        - [file path]/production/peer:/var/hyperledger/production # 입력되는 cert, msp와 생성되는 블록과 트랜잭션의 저장소**
    **ports:
      - [host port]:7051**
    deploy:
        mode: replicated
        replicas: 1
        restart_policy:
          condition: on-failure
    **networks:
      [network name]:
        aliases:
          - peer1.org1.ssel.jbnu**
  	##########################################################################
	# cli(tools)는 하이퍼레저 패브릭 네트워크를 관리하기 위한 프로그램으로
	# 네트워크의 모든 정보를 가지고 있어야 하며 네트워킹을 위한 ip/port 정보를 가지고 있어야 함
	##########################################################################
  **cli2:
    image: hyperledger/fabric-tools:1.4.6**
    tty: true
    stdin_open: true
    environment:
      - SYS_CHANNEL=$SYS_CHANNEL
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      #- FABRIC_LOGGING_SPEC=DEBUG
      - FABRIC_LOGGING_SPEC=INFO
			#############################################################
			# cli는 1개의 피어를 환경변수에서 지정하여 동작하도록 설계됨
			# 따라서 처음 시작시에 조작할 대상 피어를 하나 입력하도록함
			#############################################################
      **- CORE_PEER_ID=cli2
      - CORE_PEER_ADDRESS=[지정된 피어 ip/url]:[port]
      - CORE_PEER_LOCALMSPID=[지정된 피어 조직 id]**
      - CORE_PEER_TLS_ENABLED=true
      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.ssel.jbnu/peers/peer1.org1.ssel.jbnu/tls/server.crt
      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.ssel.jbnu/peers/peer1.org1.ssel.jbnu/tls/server.key
      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.ssel.jbnu/peers/peer1.org1.ssel.jbnu/tls/ca.crt
      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.ssel.jbnu/users/Admin@org1.ssel.jbnu/msp
    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
    command: /bin/bash
    **volumes:**
        - /var/run/:/host/var/run/
        **- [file path]/chaincode/:/opt/gopath/src/github.com/chaincode # 체인코드는 바로 다음장에서 확인 가능함
        - [file path]/crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/
        # script는 네트워크에 채널을 생성하고 피어를 참여시키고 체인코드를 설치 및 실행시키는 과정을 담고 있음
				- [file path]/scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/
        - [file path]/channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts
    depends_on:
      - orderer2
      - peer1org1**
    deploy:
        mode: replicated
        replicas: 1
        restart_policy:
          condition: on-failure
    **networks:
      [network name]:
        aliases:
          - cli**
```

# 📜 체인코드(스마트 컨트랙트)

체인코드 개발을 위해서는 VSCode 확장 프로그램인 IBM Blockchain Platform을 추천합니다.

사진은 vscode에서 확장프로그램 검색창에서 ibm blockchain platform을 검색하여 설치한 화면입니다.

VScode에 확장 프로그램 검색 후 IBM Blockchain Platform 설치 화면

[IBM Cloud Docs](https://cloud.ibm.com/docs/blockchain?topic=blockchain-develop-vscode&locale=ko)

IBM Blockcahin Platform 가이드

# vscode 다운로드

[Visual Studio Code — Code Editing. Redefined](https://code.visualstudio.com/)

확장프로그램 → ibm blockchain platform 설치

IBM Blockchain Platform 확장

1. 체인코드 패키지를 의미합니다. 패키지란 체인코드로 작성된 파일들입니다. 아래의 myAsset 예제를 통해 내부에 있는 코드 내용을 확인해볼 수 있습니다.
2. ibm blockchain platform에서 테스팅용으로 생성할 수 있는 네트워크를 제공합니다. 네트워크 구성은 고정되어 있으며 사용자가 원하는 만큼 생성 가능합니다.
3. 하이퍼레저의 채널을 확인할 수 있고 채널에 배포된 스마트 컨트랙트를 사용해 볼 수 있습니다. 함수 호출의 결과는 vscode의 터미널에서 확인 가능합니다.
4. 하이퍼레저 패브릭 네트워크의 wallet을 볼 수 있습니다. 해당 부분에서 wallet의 틀을 다운로드할 수 있습니다. wallet을 다운 받아 현재 구성한 네트워크에 맞도록 변형하여 나중에 Dapp의 SDK에 활용합니다.

어떤 피어든 체인코드가 설치되고 실행되고 있다면 인돌서 피어입니다. 정책에 맞게 설정해주세요.

자바 기반의 체인코드는 어노테이션을 통해 함수와 데이터를 구분합니다. 또한 체인코드 SDK를 반드시 활용해야합니다. 아래의 자바 체인코드 SDK를 참고해주세요.

[fabric-chaincode-shim 1.4.8 API](https://hyperledger.github.io/fabric-chaincode-java/release-1.4/api/)

# MyAssetContract.java

⭐️⭐️ Dapp에서 호출할 수 있는 **함수를 지정**합니다. 또한 체인코드의 패키지 안에 체인코드 이름을 지정할 수 있도록 합니다.

```
/*
 * SPDX-License-Identifier: Apache-2.0
 */
package org.example;import org.hyperledger.fabric.contract.Context;
import org.hyperledger.fabric.contract.ContractInterface;
import org.hyperledger.fabric.contract.annotation.Contract;
import org.hyperledger.fabric.contract.annotation.Default;
import org.hyperledger.fabric.contract.annotation.Transaction;
import org.hyperledger.fabric.contract.annotation.Contact;
import org.hyperledger.fabric.contract.annotation.Info;
import org.hyperledger.fabric.contract.annotation.License;
import static java.nio.charset.StandardCharsets.UTF_8;// @Contract 어노테이션은 컨트랙트 정보 표기를 위함. @License, @Contact도 마찬가지
@Contract(name = "MyAssetContract",
    info = @Info(title = "MyAsset contract",
                description = "My Smart Contract",
                version = "0.0.1",
                license =
                        @License(name = "Apache-2.0",
                                url = ""),
                                contact =  @Contact(email = "chaincode@example.com",
                                                name = "chaincode",
                                                url = "<http://chaincode.me>")))@Default // 컨트랙트 지정 MyAssetContract은 패키지 안에 있는 컨트랙트들 중 하나로 인식하도록 함
public class MyAssetContract implements ContractInterface {
    public  MyAssetContract() {    }
    @Transaction() // Transaction으로 지정된 메서드는 외부에서 호출 가능함. Transaction이 없으면 호출 불가
    public boolean myAssetExists(Context ctx, String myAssetId) {
        byte[] buffer = ctx.getStub().getState(myAssetId);
        return (buffer != null && buffer.length > 0);
    }    @Transaction()
    public void createMyAsset(Context ctx, String myAssetId, String value) {
        boolean exists = myAssetExists(ctx,myAssetId);
        if (exists) {
            throw new RuntimeException("The asset "+myAssetId+" already exists");
        }
        MyAsset asset = new MyAsset();
        asset.setValue(value);
        ctx.getStub().putState(myAssetId, asset.toJSONString().getBytes(UTF_8));
    }
		...
}
```

# MyAsset.java

블록체인에서 취급하는 데이터구조에 대한 예시입니다. 어노테이션을 활용하여 저장하고자 하는 변수를 지정합니다.

```
/*
 * SPDX-License-Identifier: Apache-2.0
 */package org.example;import org.hyperledger.fabric.contract.annotation.DataType;
import org.hyperledger.fabric.contract.annotation.Property;
import com.owlike.genson.Genson;@DataType() // @DataType으로 지정해야 블록체인에 저장 가능
public class MyAsset {    private final static Genson genson = new Genson();    @Property() // 블록체인에 저장하고자 하는 변수 지정. 해당 어노테이션이 없을 경우 저장하지 않음
    private String value;    public MyAsset(){
    }    public String getValue() {
        return value;
    }    public void setValue(String value) {
        this.value = value;
    }		// 체인코드는 json의 형태로 데이터를 송수신하며 저장소에도 마찬가지로 json을 활용함
    public String toJSONString() {
        return genson.serialize(this).toString();
    }    public static MyAsset fromJSONString(String json) {
        MyAsset asset = genson.deserialize(json, MyAsset.class);
        return asset;
    }
}
```

# gradle.build

gradle.build 파일에 일반적인 라이브러리를 추가할 수 있습니다.

⭐️ 아래의 내용은 가장 기본 내용이며, 필요한 기능을 추가 및 수정하여 사용할 수 있습니다.

```
/*
 * SPDX-License-Identifier: Apache-2.0
 */
plugins {
    id 'com.github.johnrengelman.shadow' version '5.2.0'
    id 'java'
}version '0.0.1'sourceCompatibility = 1.8repositories {
    mavenLocal()
    mavenCentral()
    maven {
        url '<https://jitpack.io>'
    }
}dependencies {
		// 아래 5개의 내용은 반드시 유지해야합니다.
    implementation 'org.hyperledger.fabric-chaincode-java:fabric-chaincode-shim:2.2.0'
    implementation 'com.owlike:genson:1.6'
    testImplementation 'org.junit.jupiter:junit-jupiter:5.4.2'
    testImplementation 'org.assertj:assertj-core:3.11.1'
    testImplementation 'org.mockito:mockito-core:2.+'
}shadowJar {
    baseName = 'chaincode'
    version = null
    classifier = null    manifest {
        attributes 'Main-Class': 'org.hyperledger.fabric.contract.ContractRouter'
    }
}test {
    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
    }
}tasks.withType(JavaCompile) {
  options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation" << "-parameters"
}
```

# ⚙️ 네트워크 채널 생성과 피어 참여, 체인코드 설치 및 실행을 위한 쉘스크립트

쉘스크립트는 일부를 발췌하여 작성하였습니다. 작성된 내용은 네트워크 환경에 따라 커스터마이징이 필요합니다.

아래의 스크립트는 fabric-samples에서 현재 네트워크에 맞게 수정한 부분 중 일부입니다.

네트워크 구성은 다양할 수 있어 구체적인 숫자를 빼고 작성되었습니다.

- [peerJoin.sh](http://peerjoin.sh/)

```
#!/bin/bash# 채널 생성 단계 - cli가 있는 서버에서 cli를 통해 아래의 스크립트 동작
# 채널 생성 단계에서는 하나의 오더러를 지정하여 채널을 생성하도록 요청
# 오더러는 네트워크에 참여하는 오더러라면 무엇이든 가능함
# 완료시 channel.block 생성
ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/ssel.jbnu/orderers/orderer.ssel.jbnu/msp/tlscacerts/tlsca.ssel.jbnu-cert.pem
peer channel create -o [오더러 ip/url]:[port] -c channel -f ./channel-artifacts/channel.tx --tls true --cafile $ORDERER_CA# 피어 참여 단계 - 생성된 채널에 피어 참여
# channel.block을 활용하여 피어 참여
# 아래의 4가지 변수를 참여 시키고자 하는 피어의 정보에 맞게 입력
# 참여시키고자 하는 모든 피어에 동일하게 수행 (본 예제에서는 5개 피어이기 때문에 5번 입력함)
CORE_PEER_LOCALMSPID="OrgMSP"
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org.ssel.jbnu/peers/peer1.org.ssel.jbnu/tls/ca.crt
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org.ssel.jbnu/users/Admin@org.ssel.jbnu/msp
CORE_PEER_ADDRESS=[피어 ip/url]:[port]
peer channel join -b channel.block# 앵커피어는 체인코드의 통신을 위해 반드시 필요하며 피어 참여 후 업데이트하는 방식으로 설정함
# 앵커피어는 msp, cert를 만드는 단계에서 반드시 설정한 피어를 대상으로 해야함
peer channel update -o [오더러 ip/url]:[port] -c channel -f ./channel-artifacts/OrgMSPanchors.tx --tls true --cafile $ORDERER_CA# ===========================================================================================================
# || 아래에서부터는 체인코드 관련 코드만 작성됨
# ||
# || 체인코드 설치 및 실행 예시
# ===========================================================================================================CC_RUNTIME_LANGUAGE=java
CC_SRC_PATH=/opt/gopath/src/github.com/chaincode/
CC_VERSION=[version]# 체인코드 설치 - 다른 인돌서 피어에도 동일하게 수행
# 체인코드를 설치할 때는 피어 참여 단계에서처럼 피어 지정을 위한 환경 변수를 입력함
# 체인코드 설치 시 버전, 체인코드 소스파일 경로, 실행 언어 입력
CORE_PEER_LOCALMSPID="OrgMSP"
CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org.ssel.jbnu/peers/peer1.org.ssel.jbnu/tls/ca.crt
CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org.ssel.jbnu/users/Admin@org.ssel.jbnu/msp
CORE_PEER_ADDRESS=[피어 ip/url]:[port]
peer chaincode install -n chaincode -v $CC_VERSION -p "$CC_SRC_PATH" -l "$CC_RUNTIME_LANGUAGE"# 체인코드 인스탄시에이트 환경 변수
CONFIG_ROOT=/opt/gopath/src/github.com/hyperledger/fabric/peer
ORG_MSPCONFIGPATH=${CONFIG_ROOT}/crypto/peerOrganizations/org1.ssel.jbnu/users/Admin@org.ssel.jbnu/msp
ORG_TLS_ROOTCERT_FILE=${CONFIG_ROOT}/crypto/peerOrganizations/org1.ssel.jbnu/peers/peer1.org.ssel.jbnu/tls/ca.crt
ORDERER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/ssel.jbnu/orderers/orderer.ssel.jbnu/msp/tlscacerts/tlsca.ssel.jbnu-cert.pem# 체인코드 인스타시에이트 - 다른 인돌서 피어에도 동일하게 수행
# 어떤 채널에 배포하고 체인코드 패키지 이름, 프로그래밍 언어, 버전, 보증 정책, 실행하고자 하는 대상 피어를 지정할 수 있음
peer chaincode instantiate -o [오더러 ip/url]:[port] -C channel -n chaincode 
-l "$CC_RUNTIME_LANGUAGE" -v $CC_VERSION -c '{"Args":[]}' -P "AND('Org1MSP.member','Org2MSP.member')"\\ 
--tls --cafile ${ORDERER_TLS_ROOTCERT_FILE}     --peerAddresses [피어 ip/url]:[port]\\
--tlsRootCertFiles ${ORG_TLS_ROOTCERT_FILE}# cli는 chaincode invoke를 통해 체인코드를 실행해 볼 수 있음
peer chaincode invoke -o [오더러 ip/url]:[port] -C channel -n chaincode\\
-c '{"function":"createMyAsset","Args":["1","1111111"]}'\\    
--waitForEvent --tls                          --cafile ${ORDERER_TLS_ROOTCERT_FILE}\\   
--peerAddresses [피어 ip/url]:[port]           --peerAddresses [피어 ip/url]:[port]\\    
--tlsRootCertFiles ${ORG_TLS_ROOTCERT_FILE}   --tlsRootCertFiles ${ORG_TLS_ROOTCERT_FILE}peer chaincode invoke -o [오더러 ip/url]:[port] -C channel -n chaincode\\
-c '{"function":"readMyAsset","Args":["1"]}'  --waitForEvent         --tls\\
--cafile ${ORDERER_TLS_ROOTCERT_FILE}         --peerAddresses [피어 ip/url]:[port]\\
--peerAddresses [피어 ip/url]:[port]           --tlsRootCertFiles ${ORG_TLS_ROOTCERT_FILE}\\     
--tlsRootCertFiles ${ORG_TLS_ROOTCERT_FILE}
```

# 도커 스웜 서비스 시작

```
# 앞장에서 작성한 docker-compose 파일 경로 입력
docker stack deploy --compose-file [compose file path] ssel# cli가 동작하고 있는 서버에서 실행
docker exec $(docker ps -q -f name=cli) scripts/peerJoin.sh
```

# 도커 스웜 피어, 오더러 등 동작 확인

```
$ docker service ls
ID                  NAME                   MODE           REPLICAS            IMAGE                              PORTS
k0yb4i4v7m9x        ssel_ca1          replicated          1/1                 hyperledger/fabric-ca:1.4.6        *:13054->7054/tcp
jxkpmxn3q0h7        ssel_ca2          replicated          1/1                 hyperledger/fabric-ca:1.4.6        *:9354->7054/tcp
9muc0xk0e1cn        ssel_ca3          replicated          1/1                 hyperledger/fabric-ca:1.4.6        *:9554->7054/tcp
kpw5ci0nsppv        ssel_cli2         replicated          1/1                 hyperledger/fabric-tools:1.4.6
daskoa4n720m        ssel_orderer1     replicated          1/1                 hyperledger/fabric-orderer:1.4.6   *:13050->7050/tcp
y59hp1591yph        ssel_orderer2     replicated          1/1                 hyperledger/fabric-orderer:1.4.6   *:9250->7050/tcp
i6zrzd2y79c4        ssel_orderer3     replicated          1/1                 hyperledger/fabric-orderer:1.4.6   *:9350->7050/tcp
t5bjegu9jctn        ssel_orderer4     replicated          1/1                 hyperledger/fabric-orderer:1.4.6   *:13150->7050/tcp
qmegkthk51o8        ssel_orderer5     replicated          1/1                 hyperledger/fabric-orderer:1.4.6   *:9550->7050/tcp
jg9muleuf8o6        ssel_peer0org1    replicated          1/1                 hyperledger/fabric-peer:1.4.6      *:13051->7051/tcp
x0n0e2jcnhci        ssel_peer0org2    replicated          1/1                 hyperledger/fabric-peer:1.4.6      *:9351->7051/tcp
us1otge1a0th        ssel_peer0org3    replicated          1/1                 hyperledger/fabric-peer:1.4.6      *:9551->7051/tcp
c4vkjjfuohll        ssel_peer1org1    replicated          1/1                 hyperledger/fabric-peer:1.4.6      *:9251->7051/tcp
k0dq6e2hb637        ssel_peer1org2    replicated          1/1                 hyperledger/fabric-peer:1.4.6      *:13151->7051/tcp
```

# 🖥 체인코드와 Dapp SDK

체인코드를 개발하고 블록체인에 배포한 뒤 Dapp에서 사용하기 위해서 SDK를 활용할 수 있습니다.

wallet과 connection.json 파일이 있어야 블록체인과 연결이 가능합니다.

위의 과정으로 블록체인 네트워크가 구축되었으며 체인코드도 호출 가능하다는 전제하에 진행됩니다.

# wallet

조직의 admin, user의 키값을 가지고 있는 지갑입니다. 연결하고자 하는 피어의 사용자 정보로 활용하기 위해 필요로합니다.

wallet 파일은 ibm bloakchain platform에서 템플릿을 가져올 수 있습니다. 각 내용을 구축한 네트워크에 맞게 변경합니다.

⭐️ 파일명은 반드시 admin과 유저 명으로 하셔야합니다.

wallet 파일 구조

```
admin 파일 예시 →{
	"name":"admin",
	"type":"X509",
	"mspid":"Org1MSP",
	"enrollment":{
		"signingIdentity":"admin",
		"identity":{
			"certificate":"-----BEGIN CERTIFICATE-----\\nMIICNTCCAdugAwIBAgIUXPdtqVFN54xe...-----END CERTIFICATE-----\\n"
		}
	}
}
```

# connection.json (블록체인 네트워크와 연결하기 위해 필요)

아래의 json 내용은 위의 Client의 “connection” 빼고는 모두 생성된 네트워크에 맞게 값을 입력해주어야 합니다.

```
{
    "name": "[blockchain network name] - ex jbnu-blockchain",
    "version": "[version number] - ex) 1.0.0",
    "client": {
        "organization": "Org1", # 특정 피어를 지정하기 때문에 해당 피어의 조직을 명시함
        "connection": {
            "timeout": {
                "peer": {
                    "endorser": "300"
                }
            }
        }
    },
    "organizations": {
        "Org1": {
            "mspid": "Org1MSP",
            "peers": [
                "peer0.org1.ssel.jbnu",
                "peer1.org1.ssel.jbnu"
            ],
            "certificateAuthorities": [
                "ca.org1.ssel.jbnu"
            ]
        }
    },
    "peers": {
        "peer0.org1.ssel.jbnu": {
            "url": "grpcs://[peer 1 ip/url]:[port]",
            "tlsCACerts": {
								# pem의 값을 직접 넣어도 되고 pem의 경로를 입력하여 설정 가능
								# "path": "[pem path]"
                "pem": "-----BEGIN CERTIFICATE-----\\nMIICTzCCAfWgAwIBAgIQTFnbKji0PGK21sAsSE1XyjAKBggqhkjOPQQDAjByMQsw... -----END CERTIFICATE-----\\n"
            },
            "grpcOptions": {
                "ssl-target-name-override": "[peer 1 ip/url]",
                "hostnameOverride": "[peer 1 ip/url]"
            }
        },
        "peer1.org1.ssel.jbnu": {
            "url": "grpcs://[peer 2 ip/url]:[port]",
            "tlsCACerts": {
                "pem": "-----BEGIN CERTIFICATE-----\\nMIICTzCCAfWgAwIBAgIQTFnbKji0PGK21sAsSE1XyjAKBggqhkjOPQQDAjByMQsw...-----END CERTIFICATE-----\\n"
            },
            "grpcOptions": {
                "ssl-target-name-override": "[peer 2 ip/url]",
                "hostnameOverride": "[peer 2 ip/url]"
            }
        }
    },
    "certificateAuthorities": {
        "ca.org1.ssel.jbnu": {
            "url": "https://[ca ip/url]:[port]",
            "caName": "ca-org1",
            "tlsCACerts": {
                "pem":"-----BEGIN CERTIFICATE-----\\nMIICSTCCAe+gAwIBAgIQUBbj4xv4QodlETyYxMTRGDAKBggqhkjOPQQDAjBvMQsw...-----END CERTIFICATE-----\\n"
            },
            "httpOptions": {
                "verify": false
            }
        }
    }
}
```

# Dapp (Hyperledger Fabric Java SDK)

SDK 활용을 위해 pom.xml에 필요한 라이브러리를 아래와 같이 입력합니다. 모두 필요하기 때문에 전부 입력하셔야합니다.

예제에서는 메이븐을 사용하였는데 라이브러리만 모두 정확히 추가하실 수 있다면 gradle이든 일일이 import 하시던 상관 없습니다.

- pom.xml

```
<repositories>
    <repository>
        <id>jcenter</id>
        <url><https://jcenter.bintray.com/></url>
    </repository>
    <repository>
        <id>jitpack.io</id>
        <url><https://jitpack.io></url>
    </repository>
</repositories><dependencies>
    <!-- <https://mvnrepository.com/artifact/org.hyperledger.fabric-sdk-java/fabric-sdk-java> -->
    <dependency>
        <groupId>org.hyperledger.fabric-sdk-java</groupId>
        <artifactId>fabric-sdk-java</artifactId>
        <version>1.4.12</version>
    </dependency>    <!-- <https://mvnrepository.com/artifact/org.hyperledger.fabric/fabric-gateway-java> -->
    <dependency>
        <groupId>org.hyperledger.fabric</groupId>
        <artifactId>fabric-gateway-java</artifactId>
        <version>1.4.5</version>
    </dependency>    <!-- fabric-chaincode-java -->
    <dependency>
        <groupId>org.hyperledger.fabric-chaincode-java</groupId>
        <artifactId>fabric-chaincode-shim</artifactId>
        <version>${fabric-chaincode-java.version}</version>
        <scope>compile</scope>
    </dependency>    <!-- <https://mvnrepository.com/artifact/com.google.guava/guava> -->
    <dependency>
        <groupId>com.google.guava</groupId>
        <artifactId>guava</artifactId>
        <version>29.0-jre</version>
    </dependency>
    <!-- <https://mvnrepository.com/artifact/org.json/json> -->
    <dependency>
        <groupId>org.json</groupId>
        <artifactId>json</artifactId>
        <version>20200518</version>
    </dependency>    <!-- <https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core> -->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-core</artifactId>
        <version>2.11.1</version>
    </dependency>    <!-- <https://mvnrepository.com/artifact/com.googlecode.json-simple/json-simple> -->
    <dependency>
        <groupId>com.googlecode.json-simple</groupId>
        <artifactId>json-simple</artifactId>
        <version>1.1.1</version>
    </dependency>    <!-- <https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-yaml> -->
    <dependency>
        <groupId>com.fasterxml.jackson.dataformat</groupId>
        <artifactId>jackson-dataformat-yaml</artifactId>
        <version>2.11.1</version>
    </dependency></dependencies>
```

**Dapp 예제 코드**

위에서 만들어둔 wallet과 connection.json의 경로를 walletPath, connectionProfile에 입력하고 userID에는 wallet에 있는 user 또는 admin을 입력합니다.

하이퍼레저와 연결한 뒤 체인코드를 지정하여 호출할 수 있습니다.

아래는 예제 코드이며 setUser 함수를 사용하지 않아도 되고 Wallet, Gateway, Network 등이 하이퍼레저 패브릭 자바 SDK 입니다. 자세한 내용은 아래의 docs를 확인해주세요.

[fabric-gateway-java 1.4.5 API](https://hyperledger.github.io/fabric-gateway-java/release-1.4/)

- Dapp 예시

```
import org.hyperledger.fabric.gateway.*;public class HyperLedgerManager {
    private Wallet fabricWallet;      // 블록체인 유저
    private Gateway gateway;          // 블록체인 연결
    private Gateway.Builder builder;  // 블록체인 환경 설정
    private Network network;          // 연결된 블록체인 네트워크 활용(특히 체인코드)
    private Path walletPath;
    private Path connectionProfilePath;
    private Path networkConfigPath;    public HyperLedgerManager(String walletPath, String connectionProfile, String userID) throws IOException {
        setHyperledgerConfig(walletPath, connectionProfile, userID);
    }    private void setHyperledgerConfig(String walletPathString, String connectionProfile, String userID) throws IOException {
        Path walletPath = Paths.get(walletPathString);            // wallet 폴더 경로
        fabricWallet = Wallet.createFileSystemWallet(walletPath); // 
        networkConfigPath = Paths.get(connectionProfile);         // connection.json 파일 지정        builder = Gateway.createBuilder();
				// wallet과 connection.json을 입력하여 블록체인과 연결
        builder.identity(fabricWallet, userID).networkConfig(networkConfigPath).discovery(true);
        gateway = builder.connect(); // 블록체인 연결
    }		// 체인코드 호출 예제
		public String queryTransaction() throws ContractException {
        String resultAsString        = null;
				String CHANNEL_NAME          = "channel";          // 체인코드가 배포된 채널명
				String CONTRACT_PACKAGE_NAME = "chaincode";        // 체인코드 설치시 지정한 이름(-n chaincode)
				String CONTRACT_NAME         = "myAssetContract";  // 컨트랙트명(@default로 지정한 클래스명)
				String key                   = "1";                // 예제 키값
				String contractFunctionName  = "readMyAsset";      // 체인코드 호출 함수명        network = gateway.getNetwork(CHANNEL_NAME); // 채널을 지정하여 네트워크 객체 반환
        Contract contract = network.getContract(CONTRACT_PACKAGE_NAME, CONTRACT_NAME); // 네트워크 객체를 활용하여 체인코드 객체 호출(배포된 체인코드만 가능)				// 체인코드 트랜잭션을 발행하지 않고 인돌서 피어에서만 동작하고 실행 종료 - 단순 조회에 적합
        byte[] result = contract.evaluateTransaction(contractFunctionName, key);        // 체인코드 트랜잭션을 발행하여 블록체인에 기록됨 - 데이터 저장, 업데이트 등에 적합
				byte[] result = contract.sendTransaction(contra ctFunctionName, key);				// 반환되는 값은 byte[] 형태이며 체인코드에 작성된 형태에 따라 변환 필요
				// 예를 들어 아래의 예제에서는 String을 사용하였지만 int, double 등이 있을 수 있으며,
				// byte[] 자체 일수도 있으므로 개발자가 작성한 체인코드에 따라 데이터를 어떻게 취급할지를 현 위치에서 결정해주어야 함
        resultAsString = new String(createCarResult, StandardCharsets.UTF_8);
        return resultAsString;
    }
...
}
```

IBM Blockchain Platform의 동작으로 터미널에서 확인할 수 있는 값이 전달됩니다.

# 🐛 발생 가능한 오류

- **TLS 불일치 오류**

1. 잘못된 cert, msp 경로 설정
2. production 디렉터리에 저장된 cert, msp와 입력된 cert, msp 불일치

- **피어, 오더러 네트워킹 문제**

> url/ip 등 잘못된 입력
>
> 잘못된 port 설정
>
> genesis block, profile 등에 입력된 url/ip port 와 불일치
>
> 방화벽 해제 여부

- **체인 코드 생성 불가**

> 체인 코드 컴파일 오류
>
> 도커 스웜 오버레이 네트워크 attachable 설정 누락